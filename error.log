{"level":"error","message":"Error starting the server: Redis is already connecting/connected","stack":"Error: Redis is already connecting/connected\n    at /Users/mab/Desktop/paychess.com/chesspay-be/node_modules/ioredis/built/Redis.js:107:24\n    at new Promise (<anonymous>)\n    at EventEmitter.connect (/Users/mab/Desktop/paychess.com/chesspay-be/node_modules/ioredis/built/Redis.js:103:25)\n    at startServer (/Users/mab/Desktop/paychess.com/chesspay-be/src/index.ts:46:23)\n    at processTicksAndRejections (node:internal/process/task_queues:105:5)"}
{"level":"error","message":"Error in RealtimeMatchmaking findMatch for user undefined: Cannot read properties of undefined (reading 'toString')","stack":"TypeError: Cannot read properties of undefined (reading 'toString')\n    at RealtimeMatchmaking.findMatch (/Users/mab/Desktop/paychess.com/chesspay-be/src/worker/matchmaking/realtime.matchmaking.worker.ts:48:36)\n    at GameService.matchMakingRealTime (/Users/mab/Desktop/paychess.com/chesspay-be/src/internal/service/game.service.ts:207:63)\n    at Socket.<anonymous> (/Users/mab/Desktop/paychess.com/chesspay-be/src/internal/socket/socket.handler.ts:76:58)\n    at Socket.emit (node:events:507:28)\n    at Socket.emit (node:domain:489:12)\n    at Socket.emitUntyped (/Users/mab/Desktop/paychess.com/chesspay-be/node_modules/socket.io/dist/typed-events.js:69:22)\n    at /Users/mab/Desktop/paychess.com/chesspay-be/node_modules/socket.io/dist/socket.js:697:39\n    at processTicksAndRejections (node:internal/process/task_queues:85:11)"}
{"code":"ECONNRESET","errno":-54,"level":"error","message":"Redis connection error: read ECONNRESET","stack":"Error: read ECONNRESET\n    at TCP.onStreamRead (node:internal/stream_base_commons:216:20)","syscall":"read"}
{"code":"ETIMEDOUT","errno":-60,"level":"error","message":"Redis connection error: read ETIMEDOUT","stack":"Error: read ETIMEDOUT\n    at TCP.onStreamRead (node:internal/stream_base_commons:216:20)","syscall":"read"}
{"level":"error","message":"GAME_UPDATE_QUEUE_URL environment variable is not set. Worker cannot start."}
{"error":{"name":"CredentialsProviderError","tryNextLink":false},"level":"error","message":"Error receiving messages from SQS:"}
{"error":{"name":"CredentialsProviderError","tryNextLink":false},"level":"error","message":"Error receiving messages from SQS:"}
{"error":{"name":"CredentialsProviderError","tryNextLink":false},"level":"error","message":"Error receiving messages from SQS:"}
{"error":{"name":"CredentialsProviderError","tryNextLink":false},"level":"error","message":"Error receiving messages from SQS:"}
{"error":{"name":"CredentialsProviderError","tryNextLink":false},"level":"error","message":"Error receiving messages from SQS:"}
{"error":{"$fault":"client","$metadata":{"attempts":1,"httpStatusCode":403,"requestId":"cad07adc-c8d9-5440-a2eb-1a0524be34ca","totalRetryDelay":0},"Code":"AccessDenied","Error":{"Code":"AccessDenied","Message":"User: arn:aws:iam::160885259409:user/SQS-USER is not authorized to perform: sqs:receivemessage on resource: arn:aws:sqs:ap-south-1:160885259409:GAME-DB-EVENT-SQS because no identity-based policy allows the sqs:receivemessage action","Type":"Sender","message":"User: arn:aws:iam::160885259409:user/SQS-USER is not authorized to perform: sqs:receivemessage on resource: arn:aws:sqs:ap-south-1:160885259409:GAME-DB-EVENT-SQS because no identity-based policy allows the sqs:receivemessage action"},"Type":"Sender","__type":"com.amazon.coral.service#AccessDeniedException","message":"User: arn:aws:iam::160885259409:user/SQS-USER is not authorized to perform: sqs:receivemessage on resource: arn:aws:sqs:ap-south-1:160885259409:GAME-DB-EVENT-SQS because no identity-based policy allows the sqs:receivemessage action","name":"AccessDenied"},"level":"error","message":"Error receiving messages from SQS:"}
{"error":{"$fault":"client","$metadata":{"attempts":1,"httpStatusCode":403,"requestId":"28888700-115d-59d9-a29c-e7d9fd3143f6","totalRetryDelay":0},"Code":"AccessDenied","Error":{"Code":"AccessDenied","Message":"User: arn:aws:iam::160885259409:user/SQS-USER is not authorized to perform: sqs:receivemessage on resource: arn:aws:sqs:ap-south-1:160885259409:GAME-DB-EVENT-SQS because no identity-based policy allows the sqs:receivemessage action","Type":"Sender","message":"User: arn:aws:iam::160885259409:user/SQS-USER is not authorized to perform: sqs:receivemessage on resource: arn:aws:sqs:ap-south-1:160885259409:GAME-DB-EVENT-SQS because no identity-based policy allows the sqs:receivemessage action"},"Type":"Sender","__type":"com.amazon.coral.service#AccessDeniedException","message":"User: arn:aws:iam::160885259409:user/SQS-USER is not authorized to perform: sqs:receivemessage on resource: arn:aws:sqs:ap-south-1:160885259409:GAME-DB-EVENT-SQS because no identity-based policy allows the sqs:receivemessage action","name":"AccessDenied"},"level":"error","message":"Error receiving messages from SQS:"}
{"command":{"args":["-- KEYS[1]: The key for the global matchmaking sorted set (e.g., 'global_matchmaking_queue')\n-- ARGV[1]: The current player's rating (e.g., 1500)\n-- ARGV[2]: The current player's details as a JSON string (your \"schema structure\")\n-- ARGV[3]: The ideal rating tolerance (e.g., 50)\n-- ARGV[4]: The user's consent for an extended search ('true' or 'false')\n\nlocal queue_key = KEYS[1]\nlocal rating = tonumber(ARGV[1])\nlocal player_details_json = ARGV[2] -- This JSON string is your schema\nlocal tolerance = tonumber(ARGV[3])\nlocal extended_search_consent = ARGV[4] == 'true'\n\n-- To prevent matching with oneself, first remove the current player.\n-- This has no effect if the player isn't already in the queue.\nredis.call('ZREM', queue_key, player_details_json)\n\n-- STEP 1: Perform the initial, strict search within the ideal tolerance.\nlocal ideal_min_rating = rating - tolerance\nlocal ideal_max_rating = rating + tolerance\nlocal ideal_opponents = redis.call('ZRANGEBYSCORE', queue_key, ideal_min_rating, ideal_max_rating, 'LIMIT', 0, 1)\n\nif #ideal_opponents > 0 then\n    -- Success! Found a perfect match.\n    local opponent_details = ideal_opponents[1]\n    redis.call('ZREM', queue_key, opponent_details)\n    return {player_details_json, opponent_details}\nend\n\n-- STEP 2: If no ideal match, perform extended search if the user consented.\nif extended_search_consent then\n    -- Find the closest opponent with a HIGHER rating.\n    local higher_opp_array = redis.call('ZRANGEBYSCORE', queue_key, '(' .. rating, '+inf', 'LIMIT', 0, 1)\n\n    -- Find the closest opponent with a LOWER rating.\n    local lower_opp_array = redis.call('ZREVRANGEBYSCORE', queue_key, '(' .. rating, '-inf', 'LIMIT', 0, 1)\n\n    local final_opponent_details = nil\n\n    if #higher_opp_array > 0 and #lower_opp_array > 0 then\n        -- Both a higher and lower opponent exist. Find which one is closer.\n        local higher_opp_details = higher_opp_array[1]\n        local lower_opp_details = lower_opp_array[1]\n\n        local higher_opp_rating = tonumber(redis.call('ZSCORE', queue_key, higher_opp_details))\n        local lower_opp_rating = tonumber(redis.call('ZSCORE', queue_key, lower_opp_details))\n\n        if (higher_opp_rating - rating) < (rating - lower_opp_rating) then\n            final_opponent_details = higher_opp_details\n        else\n            final_opponent_details = lower_opp_details\n        end\n    elseif #higher_opp_array > 0 then\n        final_opponent_details = higher_opp_array[1]\n    elseif #lower_opp_array > 0 then\n        final_opponent_details = lower_opp_array[1]\n    end\n\n    if final_opponent_details then\n        -- Success! Found the next best match.\n        redis.call('ZREM', queue_key, final_opponent_details)\n        return {player_details_json, final_opponent_details}\n    end\nend\n\n-- FINAL STEP: If all match attempts are exhausted, add the player to the queue.\n-- This block is reached if:\n-- 1. No ideal match was found AND extended search was not allowed.\n-- 2. No ideal match was found AND the extended search also found no one.\nredis.call('ZADD', queue_key, rating, player_details_json)\nreturn nil","1","matchmaking_sortedset_queue","[object Object]","{\"user_id\":\"\",\"rating\":{\"blitz\":800,\"bullet\":800,\"rapid\":800,\"puzzle\":800},\"socket_id\":\"we7Dsw-mX_zTCUVfAAAC\",\"win_percentage\":0.77,\"black_win_percentage\":0.7,\"white_win_percentage\":0.3,\"username\":\"player\"}","50","false"],"name":"eval"},"level":"error","message":"Error in RealtimeMatchmaking findMatch for user : ERR user_script:18: attempt to perform arithmetic on local 'rating' (a nil value) script: fc3c26fc15a128c970304e6546baf2111a3a3b9e, on @user_script:18.","stack":"ReplyError: ERR user_script:18: attempt to perform arithmetic on local 'rating' (a nil value) script: fc3c26fc15a128c970304e6546baf2111a3a3b9e, on @user_script:18.\n    at parseError (/Users/mab/Desktop/paychess.com/chesspay-be/node_modules/redis-parser/lib/parser.js:179:12)\n    at parseType (/Users/mab/Desktop/paychess.com/chesspay-be/node_modules/redis-parser/lib/parser.js:302:14)"}
{"command":{"args":["-- KEYS[1]: The key for the global matchmaking sorted set (e.g., 'global_matchmaking_queue')\n-- ARGV[1]: The current player's rating (e.g., 1500)\n-- ARGV[2]: The current player's details as a JSON string (your \"schema structure\")\n-- ARGV[3]: The ideal rating tolerance (e.g., 50)\n-- ARGV[4]: The user's consent for an extended search ('true' or 'false')\n\nlocal queue_key = KEYS[1]\nlocal rating = tonumber(ARGV[1])\nlocal player_details_json = ARGV[2] -- This JSON string is your schema\nlocal tolerance = tonumber(ARGV[3])\nlocal extended_search_consent = ARGV[4] == 'true'\n\n-- To prevent matching with oneself, first remove the current player.\n-- This has no effect if the player isn't already in the queue.\nredis.call('ZREM', queue_key, player_details_json)\n\n-- STEP 1: Perform the initial, strict search within the ideal tolerance.\nlocal ideal_min_rating = rating - tolerance\nlocal ideal_max_rating = rating + tolerance\nlocal ideal_opponents = redis.call('ZRANGEBYSCORE', queue_key, ideal_min_rating, ideal_max_rating, 'LIMIT', 0, 1)\n\nif #ideal_opponents > 0 then\n    -- Success! Found a perfect match.\n    local opponent_details = ideal_opponents[1]\n    redis.call('ZREM', queue_key, opponent_details)\n    return {player_details_json, opponent_details}\nend\n\n-- STEP 2: If no ideal match, perform extended search if the user consented.\nif extended_search_consent then\n    -- Find the closest opponent with a HIGHER rating.\n    local higher_opp_array = redis.call('ZRANGEBYSCORE', queue_key, '(' .. rating, '+inf', 'LIMIT', 0, 1)\n\n    -- Find the closest opponent with a LOWER rating.\n    local lower_opp_array = redis.call('ZREVRANGEBYSCORE', queue_key, '(' .. rating, '-inf', 'LIMIT', 0, 1)\n\n    local final_opponent_details = nil\n\n    if #higher_opp_array > 0 and #lower_opp_array > 0 then\n        -- Both a higher and lower opponent exist. Find which one is closer.\n        local higher_opp_details = higher_opp_array[1]\n        local lower_opp_details = lower_opp_array[1]\n\n        local higher_opp_rating = tonumber(redis.call('ZSCORE', queue_key, higher_opp_details))\n        local lower_opp_rating = tonumber(redis.call('ZSCORE', queue_key, lower_opp_details))\n\n        if (higher_opp_rating - rating) < (rating - lower_opp_rating) then\n            final_opponent_details = higher_opp_details\n        else\n            final_opponent_details = lower_opp_details\n        end\n    elseif #higher_opp_array > 0 then\n        final_opponent_details = higher_opp_array[1]\n    elseif #lower_opp_array > 0 then\n        final_opponent_details = lower_opp_array[1]\n    end\n\n    if final_opponent_details then\n        -- Success! Found the next best match.\n        redis.call('ZREM', queue_key, final_opponent_details)\n        return {player_details_json, final_opponent_details}\n    end\nend\n\n-- FINAL STEP: If all match attempts are exhausted, add the player to the queue.\n-- This block is reached if:\n-- 1. No ideal match was found AND extended search was not allowed.\n-- 2. No ideal match was found AND the extended search also found no one.\nredis.call('ZADD', queue_key, rating, player_details_json)\nreturn nil","1","matchmaking_sortedset_queue","[object Object]","{\"user_id\":\"\",\"rating\":{\"blitz\":800,\"bullet\":800,\"rapid\":800,\"puzzle\":800},\"socket_id\":\"LcQRRsJAVMxAJtvqAAAF\",\"win_percentage\":0.77,\"black_win_percentage\":0.7,\"white_win_percentage\":0.3,\"username\":\"player\"}","50","false"],"name":"eval"},"level":"error","message":"Error in RealtimeMatchmaking findMatch for user : ERR user_script:18: attempt to perform arithmetic on local 'rating' (a nil value) script: fc3c26fc15a128c970304e6546baf2111a3a3b9e, on @user_script:18.","stack":"ReplyError: ERR user_script:18: attempt to perform arithmetic on local 'rating' (a nil value) script: fc3c26fc15a128c970304e6546baf2111a3a3b9e, on @user_script:18.\n    at parseError (/Users/mab/Desktop/paychess.com/chesspay-be/node_modules/redis-parser/lib/parser.js:179:12)\n    at parseType (/Users/mab/Desktop/paychess.com/chesspay-be/node_modules/redis-parser/lib/parser.js:302:14)"}
{"code":"ENOENT","errno":-2,"level":"error","message":"Failed to read Lua script for RealtimeMatchmaking: ENOENT: no such file or directory, open '/Users/mab/Desktop/paychess.com/chesspay-be/src/script/final_match.script.lua'","path":"/Users/mab/Desktop/paychess.com/chesspay-be/src/script/final_match.script.lua","stack":"Error: ENOENT: no such file or directory, open '/Users/mab/Desktop/paychess.com/chesspay-be/src/script/final_match.script.lua'\n    at readFileSync (node:fs:443:20)\n    at new RealtimeMatchmaking (/Users/mab/Desktop/paychess.com/chesspay-be/src/worker/matchmaking/realtime.matchmaking.worker.ts:45:43)\n    at new GameService (/Users/mab/Desktop/paychess.com/chesspay-be/src/internal/service/game.service.ts:41:42)\n    at Socket.<anonymous> (/Users/mab/Desktop/paychess.com/chesspay-be/src/internal/socket/socket.handler.ts:192:40)\n    at processTicksAndRejections (node:internal/process/task_queues:105:5)","syscall":"open"}
{"level":"error","message":"Error in finding match for player: Error: Could not initialize RealtimeMatchmaking: Lua script missing or unreadable."}
{"level":"error","message":"Could not close connections in time, forcing shutdown."}
